{% extends 'layout.html' %}
{% block styles %}
    <link rel="stylesheet" href="/static/css/city.css">
{% endblock %}

{% block content %}

<canvas id="stage"></canvas>

<div class="twooter">
    <header class="twooter-header">
        <img src="/static/img/twooter.svg" class="twooter-brand">
    </header>
    <ul class="twooter-feed">
        <li class="twoot">
            <div class="twoot-by"><span class="twoot-author">jack</span> <span class="twoot-meta">@jack <span class="twoot-time"> 45m</span></span></div>
            <p class="twoot-content">just setting up my twooter</p>
        </li>
    </ul>
</div>

<button class="start-simulation">simulate</button>

<div class="overlay">
    <div class="overlay-content">
    </div>
</div>

<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r74/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.5/socket.io.min.js"></script>
<script>

var City = function(rows, cols) {
    this.rows = rows;
    this.cols = cols;
    this.side = 1;
    this.margin = 1;
    this.colors = [
        0x555555,
        0xff4444,
        0xffff44,
        0x44ffff
    ];

    this.fullSide = this.side + 2*this.margin;

    this.gridWidth = this.fullSide * cols;
    this.gridDepth = this.fullSide * rows;

    // extra offset to compensate for building height
    var xOffset = 3,
        zOffset = 3;

    // for centering the city
    this.offset = {
        x: -this.gridWidth/2 + xOffset,
        z: -this.gridDepth/2 + zOffset
    }

    // initialize the grid
    this.grid = [];
    for (var i=0; i < rows; i++) {
        var row = [];
        for (var j=0; j < cols; j++) {
            row.push(null);
        }
        this.grid.push(row);
    }

    this.vehicles = [];

    this.setup();
    this.spawn();

    var fps = 30,
        self = this;
    setInterval(function() {
        self.update();
        self.render();
    }, fps);
}

City.prototype = {
    // for conveniently placing things with the offset
    place: function(obj, x, y, z) {
        obj.position.set(x + this.offset.x, y, z + this.offset.z);
        this.scene.add(obj);
    },

    // setup the scene
    setup: function() {
        var width = 960,
            height = 500,
            aspect = width/height,
            D = 1,
            light = new THREE.PointLight(0xffffff, 1, 40);

        this.scene = new THREE.Scene();
        this.renderer = new THREE.WebGLRenderer({alpha: true, canvas: document.getElementById("stage")});
        this.camera = new THREE.OrthographicCamera(-D*aspect, D*aspect, D, -D, 1, 1000),

        this.renderer.setSize(width, height);
        this.renderer.setClearColor(0xffffff, 0);
        this.scene.add( new THREE.AmbientLight(0x4000ff) );

        light.position.set(15, 20, 15);
        this.scene.add(light);

        light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1);
        this.scene.add(light);

        this.camera.zoom = 0.1;
        this.camera.position.set(20, 20, 20);
        this.camera.lookAt(this.scene.position);
        this.camera.updateProjectionMatrix();
    },

    render: function() {
        this.renderer.render(this.scene, this.camera);
    },

    update: function() {
        _.each(this.vehicles, function(v) {
            v.update();
        });
    },

    // spawn the city
    spawn: function() {
        this.spawnBuildings();
        this.spawnRoads();

        var self = this;
        for (var i=0; i < 100; i++) {
            // stagger
            setTimeout(function() {
                self.spawnVehicle();
            }, Math.random() * 2000);
        }

        //this.origin();
    },

    spawnBuilding: function(row, col) {
        var height = 1 + Math.random() * 4,
            color = _.sample(this.colors),
            geometry = new THREE.BoxGeometry(this.side, height, this.side),
            material = new THREE.MeshLambertMaterial({
                color: color
            }),
            cube = new THREE.Mesh(geometry, material),
            x = row * this.fullSide,
            z = col * this.fullSide;
        this.place(cube, x, height/2, z);
    },

    spawnBuildings: function() {
        for (var i=0; i < this.rows; i++) {
            var row = [];
            for (var j=0; j < this.cols; j++) {
                this.spawnBuilding(i, j);
            }
        }
    },

    spawnVehicle: function() {
        var radius = 0.2,
            color = _.sample(this.colors),
            geometry = new THREE.SphereGeometry(radius),
            material = new THREE.MeshBasicMaterial({
                color: color
            }),
            vehicle = new THREE.Mesh(geometry, material);

        var x = 0,
            z = 0,
            xUpdate = 0,
            zUpdate = 0;
        if (Math.random() < 0.5) {
            z = _.sample([-radius, this.gridDepth + radius]);
            var col = _.random(0, this.cols);
            x = (col-1) * this.fullSide + (this.side/2 + this.margin);
            zUpdate = z < 0 ? 0.1 : -0.1;
        } else {
            x = _.sample([-radius, this.gridWidth + radius]);
            var row = _.random(0, this.rows);
            z = (row-1) * this.fullSide + (this.side/2 + this.margin);
            xUpdate = x < 0 ? 0.1 : -0.1;
        }

        var self = this;
        vehicle.distanceTraveled = 0;
        vehicle.update = function() {
            this.position.x += xUpdate;
            this.position.z += zUpdate;

            // destroy when out of the city
            if (xUpdate !== 0) {
                this.distanceTraveled += Math.abs(xUpdate);
                if (this.distanceTraveled > self.gridWidth + 2*radius) {
                    self.scene.remove(this);
                    self.vehicles = _.without(self.vehicles, this);
                    setTimeout(function() {
                        self.spawnVehicle();
                    }, Math.random() * 1000);
                }
            } else {
                this.distanceTraveled += Math.abs(zUpdate);
                if (this.distanceTraveled > self.gridDepth + 2*radius) {
                    self.scene.remove(this);
                    self.vehicles = _.without(self.vehicles, this);
                    setTimeout(function() {
                        self.spawnVehicle();
                    }, Math.random() * 1000);
                }
            }
        };

        this.place(vehicle, x - radius, radius, z - radius);
        this.vehicles.push(vehicle);
    },

    spawnRoads: function() {
        var planeGeometry = new THREE.PlaneGeometry(this.gridWidth, this.gridDepth),
            planeMaterial = new THREE.MeshLambertMaterial( {color: 0x333333, side: THREE.DoubleSide} ),
            plane = new THREE.Mesh( planeGeometry, planeMaterial );
        plane.rotation.x = Math.PI / 2;
        this.place(plane, this.gridWidth/2 - this.margin, 0, this.gridDepth/2 - this.margin);
    },

    // to easily visually identify where the origin is (for debugging)
    origin: function() {
        var geometry = new THREE.BoxGeometry(0.2,50,0.2),
            material = new THREE.MeshLambertMaterial({
                color: 0x000000
            }),
            cube = new THREE.Mesh(geometry, material);
        cube.position.set(0,0,0);
        this.scene.add(cube);
    }
}

var city = new City(4, 4);

function slugify(str) {
  return str.toLowerCase()
    .replace(/\s+/g, '_')           // replace spaces with _
    .replace(/[^\w\-]+/g, '')       // remove all non-word chars
    .replace(/\-+/g, '_');          // replace - with single _
}

var socket = io();
$(function() {
    $('.start-simulation').on('click', function() {
        $.ajax({
            type: "POST",
            url: "/simulate",
            data: JSON.stringify({
                //race: $('[name=race]').val(),
                //education: $('[name=education]').val(),
                //employment: $('[name=employment]').val()
                race: 1,
                education: 1,
                employment: 1
            }),
            contentType: "application/json",
            success: function(data, textStatus, jqXHR) {
                // console.log("success");
            }
        });
    });

    socket.on("twooter", function(data){
        console.log('twoot received');
        console.log(data);
        var username = slugify(data.name);
        $(".twooter-feed").prepend("<li class='twoot'><div class='twoot-by'><span class='twoot-author' data-id='" + data.id + "'>" + data.name + "</span> <span class='twoot-meta'>@" + username + " <span class='twoot-time'> 45m</span></span></div><p class='twoot-content'>"+data.msg+"</p></li>");
    });

    $(".twooter-feed").on('click', '.twoot-author', function() {
        var id = $(this).data('id');
        if (!id) { return; }
        $.ajax({
            type: "GET",
            url: "/person/" + id,
            success: function(data) {
                $('.overlay').fadeIn();
                $('.overlay-content').text(JSON.stringify(data));
            }
        });
    });

    $('.overlay').on('click', function(ev) {
        $('.overlay').fadeOut();
    });
});

</script>

{% endblock %}
